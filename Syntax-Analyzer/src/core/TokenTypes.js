/**
 * =========================================
 * Token Types â€“ Lexical Category Definitions
 * =========================================
 */

export const TOKEN_TYPES = {
  KEYWORD_PROGRAM: 'KW_P',
  KEYWORD_DATATYPE: 'KW_T',
  KEYWORD_LOOP: 'KW_L',
  KEYWORD_CONDITIONAL: 'KW_C',
  KEYWORD_RESERVED: 'KW_R',
  KEYWORD_START: 'KW_START',
  KEYWORD_END: 'KW_END',
  NOISE_WORD: 'NW',
  IDENTIFIER: 'ID',
  NUMBER_LITERAL: 'NUM',
  DECIMAL_LITERAL: 'DEC',
  STRING_LITERAL: 'STR',
  BOOLEAN_LITERAL: 'BOOL',
  ASSIGNMENT_OP: 'OP_ASG',
  ARITHMETIC_OP: 'OP_AR',
  UNARY_OP: 'OP_UN',
  LOGICAL_OP: 'OP_LOG',
  RELATIONAL_OP: 'OP_REL',
  DELIMITER_LEFT_PAREN: 'DEL_LPAR',
  DELIMITER_RIGHT_PAREN: 'DEL_RPAR',
  DELIMITER_LEFT_BRACKET: 'DEL_LBRACK',
  DELIMITER_RIGHT_BRACKET: 'DEL_RBRACK',
  DELIMITER_LEFT_BRACE: 'DEL_LBRACE',
  DELIMITER_RIGHT_BRACE: 'DEL_RBRACE',
  DELIMITER_COLON: 'DEL_COL',
  DELIMITER_COMMA: 'DEL_COMMA',
  DELIMITER_SEMICOLON: 'DEL_SEMI',
  DELIMITER: 'DEL',
  STRING_INSERTION: 'SIS',
  COMMENT_SINGLE: 'CMT',
  COMMENT_MULTI: 'CMT',
  UNKNOWN: 'UNK',
  ERROR: 'ERR',
};

export const KEYWORDS = {
  function: TOKEN_TYPES.KEYWORD_PROGRAM,
  start: TOKEN_TYPES.KEYWORD_START,
  end: TOKEN_TYPES.KEYWORD_END,
  echo: TOKEN_TYPES.KEYWORD_PROGRAM,
  input: TOKEN_TYPES.KEYWORD_PROGRAM,
  return: TOKEN_TYPES.KEYWORD_RESERVED,
  struct: TOKEN_TYPES.KEYWORD_RESERVED,
  data: TOKEN_TYPES.KEYWORD_RESERVED,
  number: TOKEN_TYPES.KEYWORD_DATATYPE,
  decimal: TOKEN_TYPES.KEYWORD_DATATYPE,
  string: TOKEN_TYPES.KEYWORD_DATATYPE,
  boolean: TOKEN_TYPES.KEYWORD_DATATYPE,
  list: TOKEN_TYPES.KEYWORD_DATATYPE,
  for: TOKEN_TYPES.KEYWORD_LOOP,
  while: TOKEN_TYPES.KEYWORD_LOOP,
  do: TOKEN_TYPES.KEYWORD_LOOP,
  if: TOKEN_TYPES.KEYWORD_CONDITIONAL,
  else: TOKEN_TYPES.KEYWORD_CONDITIONAL,
  then: TOKEN_TYPES.KEYWORD_CONDITIONAL,
  switch: TOKEN_TYPES.KEYWORD_CONDITIONAL,
  case: TOKEN_TYPES.KEYWORD_CONDITIONAL,
  default: TOKEN_TYPES.KEYWORD_CONDITIONAL,
  null: TOKEN_TYPES.KEYWORD_RESERVED,
  true: TOKEN_TYPES.BOOLEAN_LITERAL,
  false: TOKEN_TYPES.BOOLEAN_LITERAL,
  continue: TOKEN_TYPES.KEYWORD_RESERVED,
  break: TOKEN_TYPES.KEYWORD_RESERVED,
  new: TOKEN_TYPES.KEYWORD_RESERVED,
  this: TOKEN_TYPES.KEYWORD_RESERVED,
  with: TOKEN_TYPES.NOISE_WORD,
  to: TOKEN_TYPES.NOISE_WORD,
  by: TOKEN_TYPES.NOISE_WORD
};
